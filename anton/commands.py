# -* coding: utf-8 *-
import logging
import traceback
import re
import functools
from anton import events


"""
This module provides the glue between `events` and functions which handle IRC messages in Anton, called "commands".
Commands are registered through the `@commands.register(...)` decorator. The `anton.commands` module listens to IRC
events generated by `anton.irc_client`, namely for PRIVMSG and CHANMSG events and then matches all registered
commands against these messages. Commands are matched against incoming messages through one of three strategies:
`_regex_matcher`, `_command_matcher` or `_all_matcher`.
"""


_log = logging.getLogger(__name__)

COMMANDS = []


def _save_handler_and_filter(handlerfn, filterfn):
    COMMANDS.append((handlerfn, filterfn))


def _extract_message(irc_message_descriptor):
    """
    returns just the IRC message which was the default behavior for Anton for a long time
    """
    return irc_message_descriptor["message"]


def _return_callback(callback, result):
    """
    Calls a IRC command handler and inspects its return value. If the value is boolean it will
    return that to the caller, but if not it will write the result to IRC by calling the provided
    `callback()` function. This gives IRC handlers a choice to either call their `callback` parameter
    themselves or just return a string to respond to IRC.
    """
    if result is events.CONTINUE:
        return result

    if result is None or result is events.STOP:
        pass
    else:
        callback(result)
    return events.STOP


def _regex_matcher(regex):
    """
    If @commands.register is called with an instance of a regular expression, then it calls
    this function which returns the actual decorator used. That decorator will match IRC
    messages against the provided regex.
    """
    def decorate(handler):
        @functools.wraps(handler)
        def regex_matching_wrapper(callback, message):
            match = regex.match(message)
            if not match:
                return events.CONTINUE

            return _return_callback(callback, handler(callback, match))

        _save_handler_and_filter(regex_matching_wrapper, _extract_message)
        return regex_matching_wrapper

    return decorate


def _command_matcher(trigger_strings, argument_count=-1):
    """
    If @commands.register is either called with a string or a list of strings as its first parameter,
    then it calls this function which returns the actual decorator used. The decorator returned by
    _command will split the IRC message into words and match the first word against the passed strings.
    If one of them matches, the wrapped function will be called with the remaining message as its
    parameters.
    """
    if isinstance(trigger_strings, basestring):
        triggers = set([trigger_strings])
    else:
        triggers = set(trigger_strings)

    def decorate(handler):
        # use inspect to figure out the wrapped functions arity
        if argument_count == -1:
            argcount = handler.func_code.co_argcount - 1
        else:
            argcount = argument_count

        @functools.wraps(handler)
        def command_matching_wrapper(callback, message):
            tokens = message.split(" ", argcount)
            if not tokens[0] in triggers:
                return events.CONTINUE

            if argcount > len(tokens) - 1:
                callback("incorrect number of args for command: " + tokens[0])
                return events.STOP

            return _return_callback(callback, handler(callback, *tokens[1:]))

        _save_handler_and_filter(command_matching_wrapper, _extract_message)
        return command_matching_wrapper

    return decorate


def _all_matcher():
    """
    If @commands.register is called with just a function as its parameter, then this function is called
    to return the actual decorator used. This will call the wrapped function for every IRC message
    received.
    """
    def decorate(handler):
        @functools.wraps(handler)
        def all_matching_wrapper(callback, message):
            return _return_callback(callback, handler(callback, message))

        _save_handler_and_filter(all_matching_wrapper, _extract_message)
        return all_matching_wrapper

    return decorate


RE_TYPE = type(re.compile(""))


def register(*args, **kwargs):
    """
    Call @commands.register to register an IRC event handler. This is a simplified interface comparend
    to anton's @event.register interface that allows you to handle channel messages and private messages,
    but also requires more boilerplate. For most uses @commands.register should be easily sufficient.

    .. code-block:: python

        @commands.register     # myhandler will be called for every message received
        def myhandler(callback, args):
            pass

        @commands.register("!boink")    # myhandler will be called when somebody sends
        def myhandler(callback, args):  # a message starting with "!boink"
            pass

        @commands.register(["hello", "rofl"])  # myhandler will be called on "hello" and "rofl"
        def myhandler(callback, args):
            pass

        @commands.register(re.compile("bl[öüä]h"))  # myhandler will be called for "bläh", "blöh" and "blüh"
        def myhandler(callback, args):
            pass
    """
    if not args:
        fn = _all_matcher
    else:
        first = args[0]
        if isinstance(first, RE_TYPE):
            fn = _regex_matcher
        else:
            fn = _command_matcher

    return fn(*args, **kwargs)


@events.register("chanmsg")
def _chanmsg_handler(eventtype, irc, irc_message_descriptor):
    callback = functools.partial(irc.chanmsg, irc_message_descriptor["channel"])

    try:
        for handler_filter in COMMANDS:
            handler, msgfilter = handler_filter
            r = handler(callback, msgfilter(irc_message_descriptor))
            if r == events.STOP:
                break
    except Exception as e:
        callback("An error occured (%s). Please check the log." % e)
        _log.error(e, exc_info=True)


@events.register("privmsg")
def _privmsg_handler(eventtype, irc, irc_message_descriptor):
    callback = functools.partial(irc.privnotice, irc_message_descriptor["source"]["nick"])

    try:
        for handler_filter in COMMANDS:
            handler, msgfilter = handler_filter
            r = handler(callback, msgfilter(irc_message_descriptor))
            if r == events.STOP:
                break
    except Exception as e:
        callback("An error occured (%s). Please check the log." % e)
        _log.error(e, exc_info=True)
