# -* coding: utf-8 *-
import logging
import traceback
import re
from anton import events
from functools import wraps

"""
This module provides the glue between `events` and functions which handle IRC messages in Anton, called "commands".
Commands are registered through the `@commands.register(...)` decorator. The `anton.commands` module listens to IRC
events generated by `anton.irc_client`, namely for PRIVMSG and CHANMSG events and then matches all registered
commands against these messages. Commands are matched against incoming messages through one of three strategies:
`re_`, `command` or `all`.
"""


_log = logging.getLogger(__name__)

COMMANDS = []


def register_raw(fn, filterfn):
    COMMANDS.append((fn, filterfn))


def message_filter(obj):
    """
    returns just the IRC message which was the default behavior for Anton for a long time
    """
    return obj["message"]


def return_callback(callback, result):
    """
    Calls a IRC command handler and inspects its return value. If the value is boolean it will
    return that to the caller, but if not it will write the result to IRC by calling the provided
    `callback()` function. This gives IRC handlers a choice to either call their `callback` parameter
    themselves or just return a string to respond to IRC.
    """
    if result is events.CONTINUE:
        return result

    if result is None or result is events.STOP:
        pass
    else:
        callback(result)
    return events.STOP


def re_(r):
    """
    If @commands.register is called with an instance of a regular expression, this function returns
    the actual decorator used, which will match IRC messages against said regex.
    """
    def decorate(fn):
        @wraps(fn)
        def new_fn(callback, message):
            m = r.match(message)
            if not m:
                return events.CONTINUE

            return return_callback(callback, fn(callback, m))

        register_raw(new_fn, message_filter)
        return new_fn

    return decorate


def command(name, args=-1):
    """
    If @commands.register is either called with a string or a list of strings as its first parameter,
    then this function returns the actual decorator used. This will split the IRC message into words
    and match the first word against the passed strings. If one of them matches, the handler will
    be called with the remaining message as its parameters.
    """
    if isinstance(name, basestring):
        names = set([name])
    else:
        names = set(name)

    def decorate(fn):
        if args == -1:
            args2 = fn.func_code.co_argcount - 1
        else:
            args2 = args

        @wraps(fn)
        def new_fn(callback, message):
            tokens = message.split(" ", args2)
            if not tokens[0] in names:
                return events.CONTINUE

            if args2 > len(tokens) - 1:
                callback("incorrect number of args for command: " + tokens[0])
                return events.STOP

            return return_callback(callback, fn(callback, *tokens[1:]))

        register_raw(new_fn, message_filter)
        return new_fn

    return decorate


def all():
    def decorate(fn):
        @wraps(fn)
        def new_fn(callback, message):
            return return_callback(callback, fn(callback, message))

        register_raw(new_fn, message_filter)
        return new_fn

    return decorate


RE_TYPE = type(re.compile(""))
FN_TYPE = type(lambda: None)


def register(*args, **kwargs):
    if not args:
        fn = all
    else:
        first = args[0]
        if isinstance(first, FN_TYPE):
            fn = all()
        elif isinstance(first, RE_TYPE):
            fn = re_
        else:
            fn = command

    return fn(*args, **kwargs)


@events.register("chanmsg")
def chanmsg_handler(type, irc, obj):
    callback = lambda x: irc.chanmsg(obj["channel"], x)

    try:
        for tuple in COMMANDS:
            command, msgfilter = tuple
            r = command(callback, msgfilter(obj))
            if r == events.STOP:
                break
    except Exception as e:
        callback("An error occured (%s). Please check the log." % e)
        _log.error(e, exc_info=True)


@events.register("privmsg")
def privmsg_handler(type, irc, obj):
    callback = lambda x: irc.privnotice(obj["source"]["nick"], x)

    try:
        for tuple in COMMANDS:
            command, msgfilter = tuple
            r = command(callback, msgfilter(obj))
            if r == events.STOP:
                break
    except Exception as e:
        callback("An error occured (%s). Please check the log." % e)
        _log.error(e, exc_info=True)
